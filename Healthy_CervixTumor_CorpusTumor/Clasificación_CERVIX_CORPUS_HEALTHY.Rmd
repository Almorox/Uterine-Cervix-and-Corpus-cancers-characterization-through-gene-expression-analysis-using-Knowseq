---
title: "Clasificación CERVIX - CORPUS - HEALTHY"
author: "Lucía Almorox Antón"
date: "2023-01-24"
output: html_document
---

This code was created for the study "Uterine Cervix and Corpus Cancers Characterization through Gene Expression Analysis Using the Knowseq Tool".

Department of Computer Engineering, Automatics and Robotics,University of Granada. C.I.T.I.C., Periodista Rafael G´omez Montero, 2, 18014. Granada, Spain.

luciaalmorox@correo.ugr.es

```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
require(KnowSeq)
require(caret)
par(mar=c(3,3,2,2))
set.seed(111)
memory.limit(size=10000)
```

En este documento se parte de la matriz de expresión corregida y las etiquetas de las muestras que aparecen en ella. Estos objetos han sido creados con el documento "Preprocesamiento_CERVIX_CORPUS.Rmd".

```{r 1}
#rm(list = ls())
load("MATRIZ_LIMPIA.RData")
load("quality_labels.RData")
```

```{r}
table(qualityLabels)
```

# 1. División train y test (80-20)

```{r}
set.seed(333)
train_index <- sample(seq(1:ncol(batchMatrix)),as.integer(0.8*ncol(batchMatrix)))
XTRN = batchMatrix[,train_index]
YTRN = qualityLabels[train_index]

XTEST = batchMatrix[,-train_index]
YTEST = qualityLabels[-train_index]

cat("\n Número de muestras en el conjunto de entrenamiento: \n")
ncol(XTRN)
cat("\n Número de muestras en el conjunto de validación: \n")
ncol(XTEST)
cat("\n Muestras de cada tipo en el conjunto de entrenamiento: \n")
table(YTRN)

cat("\n Muestras de cada tipo en el conjunto de validación: \n")
table(YTEST)
```

# 2. Extracción de genes diferencialmente expresados y visualización. 

```{r}
set.seed(111)
# Extraemos los genes diferencialmente destacados teniendo en cuenta las 
# correccion mediante SVA
 
DEGsInfo <- DEGsExtraction(XTRN, YTRN, lfc = 2, pvalue = 0.001, cov=2)



# Extraemos la tabla de estadisticas de los genes diferencialmente expresados, 
# asi como la matriz ya filtrada con dichos genes.
topTable <- DEGsInfo$DEG_Results$MulticlassLFC
DEGsMatrix <- DEGsInfo$DEG_Results$DEGs_Matrix

# Top-12 boxplots y heatmap
dataPlot(DEGsMatrix[1:6,], YTRN, mode = "genesBoxplot", toPNG=F, 
toPDF=F)

#dataPlot(DEGsMatrix[7:12,], YTRN, mode = "genesBoxplot", toPNG=F, 
#toPDF=T)

dataPlot(DEGsMatrix[1:12,], YTRN, mode = "heatmap", toPNG=F, toPDF=F)
```

```{r}
nrow(DEGsMatrix)
```

```{r}
dataPlot(DEGsMatrix[1:12,], YTRN, mode = "genesBoxplot", toPNG=F, 
toPDF=F)
```


```{r}
topTable[1:12,]
write.table(topTable[1:12,], file= "toptable12.csv", dec = '.', row.names = T, col.names = T, quote=F, sep=',')

```

# 3. Identificación de biomarcadores (comparar selección por mrmr, da y rf, en cto entrenamiento).

```{r}


# Se preparan tanto la matriz como los labels
MLMatrix <- t(DEGsMatrix) # LOS GENES EN LAS COLS Y LAS MUESTRAS EN LAS FILAS
MLLabels <- YTRN


# Llevamos a cabo un proceso de Seleccion de Caracteristicas (genes)
# Utilizamos ahora 3 criterios diferentes de selección: mrmr, rf, da (relaciona 
# con la enfermedad)
# De cada ranking seleccionamos solo los primeros 20 genes.
FSRankingMRMR <- featureSelection(MLMatrix, MLLabels, mode = "mrmr", 
                                  vars_selected = colnames(MLMatrix))[1:10]
FSRankingRF <- featureSelection(MLMatrix, MLLabels, mode = "rf", vars_selected 
                                = colnames(MLMatrix))[1:10]
FSRankingDA <- featureSelection(MLMatrix, MLLabels, mode = "da", 
                      disease="uterus", vars_selected =colnames(MLMatrix))[1:10]

# Guardamos los nombres de los rankins para usarlos como títulos de las 
# gráficas generadas
RanksNames <- c("MRMR","RF","DA")

# Evaluamos los biomarcadores mediante un proceso de validacion cruzada, CON 
# KNN DE KNOWSEQ
ALLrankings = list(FSRankingMRMR,FSRankingRF,FSRankingDA)
RANKINGS_ACC = data.frame()
ACC_TST <- data.frame()

for(i in 1:3){
  
  # Realizamos esta bifurcación porque el formato que devuelve el método 
  # featureSelection
  # es diferente cuando se usa el modo "rf" (devuelve directamente los nombres).
  if (i ==1|i==3){
    use_rank <- names(ALLrankings[[i]])
  
  } else {
   use_rank <- ALLrankings[[i]]
  }
  use_rank <- use_rank[!is.na(use_rank)]
   knn_trn <- knn_trn(MLMatrix, MLLabels, vars_selected = use_rank)
   # por defecto hace un 10-fold cross validation
   
   # Guardamos los resultados de precisión, sensibilidad y especifidad
  knn_results <- rbind(knn_trn$accuracyInfo$meanAccuracy,        knn_trn$sensitivityInfo$meanSensitivity,knn_trn$specificityInfo$meanSpecificity)

  # Guardamos a parte los resultados de precisión obtenidos para cada ranking,
  # para compararlos posteriormente en una misma gráfica.
RANKINGS_ACC <- rbind(RANKINGS_ACC,knn_trn$accuracyInfo$meanAccuracy)

# Para cada ranking, visualizamos las medidas de precisión, sensibilidad y 
# especifidad.
dataPlot(knn_results, MLLabels, legend = c("Mean Accuracy","Mean Sensitivity",
                                    "Mean Specificity"), mode = "classResults", 
  main=paste("Ranking",RanksNames[i]), xlab="# Genes", ylab="Prediction Score")
#dataPlot(knn_trn, MLLabels, mode = "heatmapResults")

#dataPlot(knn_results[,1:4], MLLabels, legend = c("Mean Accuracy",
# "Mean Sensitivity","Mean Specificity"), mode = "classResults")

# Para cada ranking obtenemos el heatmap (de los 3 primeros genes del ranking),
# la matriz de confusión
# y el boxplot (de los 3 pimeros genes del ranking).

dataPlot(t(MLMatrix[,use_rank[1:3]]), MLLabels, 
         mode = "heatmap",main=paste("Ranking",RanksNames[i]))
dataPlot(knn_trn$cfMats[[3]]$table, MLLabels, mode = "confusionMatrix",
         main=paste("Ranking",RanksNames[i]))
dataPlot(t(MLMatrix[,use_rank[1:3]]), MLLabels, mode = "genesBoxplot",
         main=paste("Ranking",RanksNames[i]))

# TEST
results_test_knn <- knn_test(MLMatrix, MLLabels, t(XTEST),
YTEST, use_rank, bestK = knn_trn$bestK)
 
 ACC_TST <- rbind(ACC_TST,unname(results_test_knn$accVector))

}


```


```{r}
top10_3ranks <- as.data.frame(rbind(t(as.data.frame(names(FSRankingMRMR))),t(as.data.frame(FSRankingRF)),t(as.data.frame(names(FSRankingDA)))))[,1:10]
colnames(top10_3ranks) <- c("GEN 1","GEN 2","GEN 3","GEN 4","GEN 5","GEN 6","GEN 7","GEN 8","GEN 9","GEN 10")
row.names(top10_3ranks) <- c("Ranking MRMR","Ranking RF", "Ranking DA")
top10_3ranks
write.table(top10_3ranks, file= "top10_3ranks.csv", dec = '.', row.names = T, col.names = T, quote=F, sep=',')
```



Visualizamos la tasa de acierto del entrenamiento en función el número de genes utilizado, para los 3 rankings.

```{r}
dataPlot(as.matrix(RANKINGS_ACC), MLLabels, legend = c("MRMR","RF","DA"), 
mode = "classResults" , main=paste("KNN Train Accuracy"), xlab="# Genes", 
ylab="Prediction Score")


```

Visualizamos la tasa de acierto de la validación en función el número de genes utilizado, para los 3 rankings.

```{r}


dataPlot(as.matrix(ACC_TST), MLLabels, legend = c("MRMR","RF","DA"), 
mode = "classResults" , main=paste("Test accuracy using 3 different gene rankings"), xlab="# Genes", 
ylab="Prediction Score")

```


# 4. Heatmap, clasificador definitivo, y resultado en conjunto de test (matriz de confusión).

```{r, fig.width=5, fig.height=3, out.width='600px'}
set.seed(222)
par(mar=c(3,3,2,2))
knn_trn <- knn_trn(MLMatrix, MLLabels, vars_selected = names(FSRankingMRMR))

results_test_knn <- knn_test(MLMatrix, MLLabels, t(XTEST),
YTEST, names(FSRankingMRMR), bestK = knn_trn$bestK)

dataPlot(results_test_knn$cfMats[[3]]$table, MLLabels, mode = "confusionMatrix",
         main="Conf. Matrix - TEST - ranking MRMR - Number of genes: 3", toPNG = T)

dataPlot(results_test_knn$cfMats[[4]]$table, MLLabels, mode = "confusionMatrix",
         main="Conf. Matrix - TEST - ranking MRMR - Number of genes: 3", toPNG = T)
         
ret <- rbind(results_test_knn$accVector,results_test_knn$sensVector,results_test_knn$specVector)



dataPlot(as.matrix(ret), MLLabels, legend=c("Accuracy","Sensitivity",
                                    "Specificity"), 
mode = "classResults", main=paste("KNN Test quality measures - ranking MRMR"), xlab="# Genes", 
ylab="Prediction Score")

dataPlot(t(MLMatrix[,names(FSRankingMRMR)[1:5]]), MLLabels, 
         mode = "heatmap")
```

```{r}
dataPlot(as.matrix(ret), MLLabels, legend=c("Accuracy","Sensitivity",
                                    "Specificity"), 
mode = "classResults", main=paste("Test quality measures using MRMR ranking"), xlab="# Genes", 
ylab="Prediction Score")
```


Resultados utilizando los 4 primeros genes del ranking MRMR para la clasificación:

```{r}
results_test_knn$cfMats[[4]]$overall
results_test_knn$cfMats[[4]]$table
dataPlot(results_test_knn$cfMats[[4]]$table, MLLabels, mode = "confusionMatrix",
         main="Conf. Matrix - TEST - ranking MRMR - Number of genes: 3")
results_test_knn$accVector[[4]]
```



# 5. Dar los resultados de las huellas escogidas por uno de los algoritmos en las 5 ejecuciones 5-CV (5 rankings), y comparar resultados. 

A continuación, utilizamos únicamente el método "MRMR" para realizar el ranking de genes con mayor importancia para predecir la variable de salida (utilizamos solo los 10 primeros genes del ranking). En este caso, realizamos una validación cruzada 5-fold. Con cada fold, entrenamos un clasificador Knn (obtenemos las 3 medidas de calidad anteriores del entrenamiento) y utilizamos el subconjunto de validación para predecir las clases de cada muestra y obtener la precisión de dicha validación.

Para cada fold obtenemos, además, las cuatro gráficas (heatmap, matriz de confusión, boxplot y gráficas con las medidas de calidad en función del número de genes) relativas al entrenamiento.`



```{r}
set.seed(222)

#SUBDIV TRANI TEST -> COGIENDO CADA VEZ UN FOLD
FOLDS_ACC_TRN = data.frame()
FOLDS_ACC_TST = data.frame()
TABLA_10_GENES = data.frame()

expressionMatrixCorrected <- batchMatrix # volvemos a utilizar la matriz que
                                         # contiene todas las muestras
                                         # (no solo el subconjunto train ni test)
help("createFolds")
cv.Index <- createFolds(qualityLabels,5,returnTrain = T)
for (oneFOLD in 1:5 ){
  train_ind = cv.Index[[oneFOLD]]
  XTRN =expressionMatrixCorrected[,train_ind] # muestras en las cols 
                                              # (seleccionas muestras)
                                              # los genes (filas) los coges 
                                              # todos siempre claro
  XTEST = expressionMatrixCorrected[,-train_ind]

  YTRN= qualityLabels[train_ind]
  YTEST=qualityLabels[-train_ind]
 

# Extraemos los genes diferencialmente destacados teniendo en cuenta las 
# correccion mediante SVA
 
  DEGsInfo <- DEGsExtraction(XTRN, YTRN, lfc = 2, pvalue = 0.001, cov=2)



# Extraemos la tabla de estadisticas de los genes diferencialmente expresados, 
  # así como la matriz ya filtrada con dichos genes.
  topTable <- DEGsInfo$DEG_Results$MulticlassLFC
  DEGsMatrix <- DEGsInfo$DEG_Results$DEGs_Matrix

# Top-12 boxplots y heatmap
  dataPlot(DEGsMatrix[1:12,], YTRN, mode = "genesBoxplot", toPNG=FALSE, 
           toPDF=FALSE, main=paste("FOLD",oneFOLD))

  dataPlot(DEGsMatrix[1:12,], YTRN, mode = "heatmap", toPNG=FALSE, toPDF=FALSE,
           main=paste("FOLD",oneFOLD))


# Se preparan tanto la matriz como los labels
MLMatrix <- t(DEGsMatrix) # LOS GENES EN LAS COLS Y LAS MUESTRAS EN LAS FILAS
MLLabels <- YTRN #SUPONGO

# Llevamos a cabo un proceso de Seleccion de Caracteristicas
# AHORA SOLO MRMR
FSRankingMRMR <- featureSelection(MLMatrix, MLLabels, mode = "mrmr", 
                                  vars_selected = colnames(MLMatrix))
TABLA_10_GENES <- rbind(TABLA_10_GENES,names(FSRankingMRMR)[1:10])



   knn_trn <- knn_trn(MLMatrix, MLLabels, 
                      vars_selected = names(FSRankingMRMR)[1:10])
   # por defecto hace un 10 cross validation
  knn_results <- rbind(knn_trn$accuracyInfo$meanAccuracy,        knn_trn$sensitivityInfo$meanSensitivity,knn_trn$specificityInfo$meanSpecificity)


  FOLDS_ACC_TRN <- rbind(FOLDS_ACC_TRN,
                         unname(knn_trn$accuracyInfo$meanAccuracy))
  
dataPlot(knn_results, MLLabels, legend = c("Mean Accuracy","Mean Sensitivity",
                                    "Mean Specificity"), mode = "classResults", 
         main=paste("FOLD",oneFOLD), xlab="# Genes", ylab="Prediction Score")
#dataPlot(knn_trn, MLLabels, mode = "heatmapResults")

#dataPlot(knn_results[,1:4], MLLabels, legend = c("Mean Accuracy",
#"Mean Sensitivity","Mean Specificity"), mode = "classResults")

dataPlot(t(MLMatrix[,names(FSRankingMRMR[1:3])]), MLLabels, mode = "heatmap",
         main=paste("FOLD",oneFOLD))
dataPlot(knn_trn$cfMats[[3]]$table, MLLabels, mode = "confusionMatrix",
         main=paste("FOLD",oneFOLD))
dataPlot(t(MLMatrix[,names(FSRankingMRMR[1:3])]), MLLabels, mode = "genesBoxplot",
         main=paste("FOLD",oneFOLD))


# Ahora con el TEST:
 
 results_test_knn <- knn_test(MLMatrix, MLLabels, t(XTEST),
YTEST, names(FSRankingMRMR)[1:10], bestK = knn_trn$bestK)
 
 FOLDS_ACC_TST <- rbind(FOLDS_ACC_TST,unname(results_test_knn$accVector))
 if (oneFOLD==1){
   AllMats <- results_test_knn$cfMats[[3]]$table
 } else {
   AllMats <- AllMats + results_test_knn$cfMats[[3]]$table # NUEVO ELSE
 }
 

}

```




## 4.1. Gráfica de la precisión del entrenamiento de cada fold en función del número de genes utilizados.


```{r}
dataPlot(as.matrix(FOLDS_ACC_TRN), MLLabels, legend = c("FOLD 1","FOLD 2",
  "FOLD 3", "FOLD 4", "FOLD 5"), mode = "classResults", 
  main=paste("CV KNN Accuracy - TRAIN"), xlab="# Genes", ylab="Prediction Score")

```

## 4.2. Suma de las matrices de confusión de las validaciones de cada fold.


El número de genes seleccionados es 3.

```{r}
dataPlot(AllMats, MLLabels, mode = "confusionMatrix")
```

## 4.3. Tabla con los 10 primeros genes del ranking MRMR obtenido con cada fold.

```{r}
colnames(TABLA_10_GENES) <- c("Gen1","Gen2","Gen3","Gen4","Gen5","Gen6","Gen7",
                              "Gen8","Gen9","Gen10")
row.names(TABLA_10_GENES) <- c("Fold1","Fold2","Fold3","Fold4","Fold5")
TABLA_10_GENES
write.csv(file = "TABLA_10_GENES_CV.csv", x = TABLA_10_GENES)
```
Posible huella génica: 
'CLDN15', 'VWCE'



Gráfica de la precisión del entrenamiento y la validación de cada fold en función del número de genes utilizados.

```{r}
library("ggplot2")
num_genes <- 1:10
folds_label <- c("Fold1","Fold2","Fold3","Fold4","Fold5")
colnames(FOLDS_ACC_TRN) <- num_genes
rownames(FOLDS_ACC_TRN) <- folds_label
trn_dat <- t(FOLDS_ACC_TRN)
trn_dat <- cbind(trn_dat,1:10)
colnames(trn_dat)[6] <- "NGENES"
trn_dat <- as.data.frame(trn_dat)


colnames(FOLDS_ACC_TST) <- num_genes
rownames(FOLDS_ACC_TST) <- folds_label
tst_dat <- t(FOLDS_ACC_TST)
tst_dat <- cbind(tst_dat,1:10)
colnames(tst_dat)[6] <- "NGENES"
tst_dat <- as.data.frame(tst_dat)


color1 <- rgb(9/255, 137/255, 134/255, maxColorValue = 1)
color2 <- rgb(255/255, 198/255, 51/255, maxColorValue = 1)
color3 <- rgb(253/255, 128/255, 174/255, maxColorValue = 1)
color5 <- rgb(14/255, 14/255, 15/255, maxColorValue = 1)
color4 <- rgb(51/255, 243/255, 25/255, maxColorValue = 1)
plot1<-ggplot(trn_dat, mapping= aes(x = NGENES, y=Fold1)) + 
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold1, colour='Fold1', 
                                linetype = "TRAIN"),linewidth=0.4)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold2, colour='Fold2', 
                                linetype = "TRAIN"),linewidth=0.4)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold3, colour='Fold3',
                                linetype = "TRAIN"),linewidth=0.4)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold4, colour='Fold4', 
                                linetype = "TRAIN"),linewidth=0.4)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold5, colour='Fold5', 
                                linetype = "TRAIN"),linewidth=0.4)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold1, colour='Fold1', 
                               linetype = "TEST"),linewidth=0.4)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold2, colour='Fold2', 
                               linetype = "TEST"),linewidth=0.4)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold3, colour='Fold3', 
                               linetype = "TEST"),linewidth=0.4)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold4, colour='Fold4', 
                               linetype = "TEST"),linewidth=0.4)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold5, colour='Fold5', 
                               linetype = "TEST"),linewidth=0.3)+
  theme_bw()+
  scale_y_continuous(name="Accuracy",limits = c(0.91,1),
        breaks = round(seq(0.8, 1, by = 0.02),2))+
  scale_x_continuous(name="# genes",limits = c(1,10),
        breaks = seq(1, 20, by = 1))+
  scale_color_manual(name='Color',
        breaks=c('Fold1','Fold2','Fold3','Fold4','Fold5'),
        values = c('Fold1'=color1, 'Fold2'=color2, 'Fold3'=color3, 
        'Fold4'=color4,'Fold5'=color5))+
  scale_linetype_manual(name= 'Line type', breaks=c('TRAIN','TEST'),
        values=c('TRAIN'='solid','TEST'='longdash'))+
  theme(legend.key.size = unit(1, 'cm'))

plot1
# +theme(plot.title = element_text(size=12,face='bold',hjust = 0.5)) 
```

Gráfica de la precisión media del entrenamiento y la validación en función del número de genes utilizados.

```{r}

trn_dat_mean <- apply(trn_dat[,1:5], 1, mean)
trn_dat_mean <- as.data.frame(cbind(trn_dat_mean,trn_dat[,6]))
colnames(trn_dat_mean)[2] <- "NGENES"

tst_dat_mean <-  apply(tst_dat[,1:5], 1, mean)
tst_dat_mean <- as.data.frame(cbind(tst_dat_mean,tst_dat[,6]))
colnames(tst_dat_mean)[2] <- "NGENES"

color1 <- rgb(9/255, 137/255, 134/255, maxColorValue = 1)
color2 <- rgb(255/255, 198/255, 51/255, maxColorValue = 1)


plot1<-ggplot(trn_dat_mean, mapping= aes(x = NGENES, y=trn_dat_mean)) + 
  geom_line(data = trn_dat_mean, aes(x = NGENES, y=trn_dat_mean, 
                                linetype = "TRAIN"),color= color1, linewidth=0.8)+
  geom_line(data = tst_dat_mean, aes(x = NGENES, y=tst_dat_mean, 
                                linetype = "TEST"),color=color1,linewidth=0.8)+
  theme_bw()+
  scale_y_continuous(name="Mean accuracy",limits = c(0.955,1),
        breaks = round(seq(0.8, 1, by = 0.01),2))+
  scale_x_continuous(name="# Genes (MRMR ranking)",limits = c(1,10),
        breaks = seq(1, 20, by = 1))+
  scale_linetype_manual(name= '', breaks=c('TRAIN','TEST'),
        values=c('TRAIN'='solid','TEST'='longdash'))+
  ggtitle("5-FOLD CV - Mean train and test accuracy")+
  theme(legend.key.size = unit(1, 'cm'),legend.text=element_text(size=14), axis.text=element_text(size=14),
        axis.title=element_text(size=16),plot.title = element_text(size=15,face='bold',hjust = 0.5))

plot1


png("mean_acc_train_test_5cv.png", units="in", width=10, height=5, res=300)
plot1
dev.off()
# +theme(plot.title = element_text(size=12,face='bold',hjust = 0.5)) 
```

# 6. Tomar una huella final, probarla en 5CV y dar la matriz de confusión final con todos los datos.


```{r}
set.seed(323)

selecc <- c('CLDN15', 'VWCE')
#SUBDIV TRANI TEST -> COGIENDO CADA VEZ UN FOLD
FOLDS_ACC_TRN = data.frame()
FOLDS_ACC_TST = data.frame()


for (oneFOLD in 1:5 ){
  train_ind = cv.Index[[oneFOLD]]
  # muestras en las cols (seleccionas muestras)
  XTRN =expressionMatrixCorrected[,train_ind] 
  
  # los genes (filas) los coges todos siempre claro
  XTEST = expressionMatrixCorrected[,-train_ind]

  YTRN= qualityLabels[train_ind]
  YTEST=qualityLabels[-train_ind]
 

# Se preparan tanto la matriz como los labels
MLMatrix <- t(XTRN) # LOS GENES EN LAS COLS Y LAS MUESTRAS EN LAS FILAS
MLLabels <- YTRN #

# YA NO Llevamos a cabo un proceso de Selección de Caracteristicas
# YA ESTÁN SELECCIONADAS

knn_trn <- knn_trn(MLMatrix, MLLabels, vars_selected = selecc)
  # por defecto hace un 10 cross validation
knn_results <- rbind(knn_trn$accuracyInfo$meanAccuracy,        knn_trn$sensitivityInfo$meanSensitivity,knn_trn$specificityInfo$meanSpecificity)


FOLDS_ACC_TRN <- rbind(FOLDS_ACC_TRN,unname(knn_trn$accuracyInfo$meanAccuracy))
dataPlot(knn_results, MLLabels, legend = c("Mean Accuracy","Mean Sensitivity",
                                           "Mean Specificity"), mode = "classResults", main=paste("FOLD",oneFOLD), xlab="# Genes", ylab="Prediction Score")


dataPlot(t(MLMatrix[,selecc]), MLLabels, mode = "heatmap",
         main=paste("FOLD",oneFOLD))
dataPlot(knn_trn$cfMats[[3]]$table, MLLabels, mode = "confusionMatrix",
         main=paste("FOLD",oneFOLD))
dataPlot(t(MLMatrix[,selecc]), MLLabels, mode = "genesBoxplot"
         ,main=paste("FOLD",oneFOLD))


# Ahora con el TEST:
 
 results_test_knn <- knn_test(MLMatrix, MLLabels, t(XTEST),
YTEST, selecc, bestK = knn_trn$bestK)
 
 FOLDS_ACC_TST <- rbind(FOLDS_ACC_TST,unname(results_test_knn$accVector))
 
 if (oneFOLD==1){
   AllMats <- results_test_knn$cfMats[[2]]$table
 } else {
    AllMats <- AllMats + results_test_knn$cfMats[[2]]$table
 }



}


```



 Gráfica de la precisión del entrenamiento de cada fold en función del número de genes utilizados.


```{r}
dataPlot(as.matrix(FOLDS_ACC_TRN), MLLabels, legend = c("FOLD 1","FOLD 2",
"FOLD 3", "FOLD 4", "FOLD 5"), mode = "classResults", main=paste("CV KNN Accuracy - TRAIN - HUELLA"),
xlab="# Genes", ylab="Prediction Score")

```

Suma de las matrices de confusión de la validación de cada fold:

```{r}
help(dataPlot)
dataPlot(AllMats, MLLabels, mode = "confusionMatrix")
```

Matriz de confusión de la validaicón del último fold utilizando solo el primer gen de la huella:

```{r}
dataPlot(results_test_knn$cfMats[[1]]$table, MLLabels, mode = "confusionMatrix")
```

Valores de precisión en función del número de genes para el entrenamiento y la validación de cada fold.

```{r}
num_genes <- c(1,2)
folds_label <- c("Fold1","Fold2","Fold3","Fold4","Fold5")
colnames(FOLDS_ACC_TRN) <- num_genes
rownames(FOLDS_ACC_TRN) <- folds_label
trn_dat <- t(FOLDS_ACC_TRN)
trn_dat <- cbind(trn_dat,1:2)
colnames(trn_dat)[6] <- "NGENES"
trn_dat <- as.data.frame(trn_dat)

colnames(FOLDS_ACC_TST) <- num_genes
rownames(FOLDS_ACC_TST) <- folds_label
tst_dat <- t(FOLDS_ACC_TST)
tst_dat <- cbind(tst_dat,1:2)
colnames(tst_dat)[6] <- "NGENES"
tst_dat <- as.data.frame(tst_dat)

color1 <- rgb(9/255, 137/255, 134/255, maxColorValue = 1)
color2 <- rgb(255/255, 198/255, 51/255, maxColorValue = 1)
color3 <- rgb(253/255, 128/255, 174/255, maxColorValue = 1)
color5 <- rgb(14/255, 14/255, 15/255, maxColorValue = 1)
color4 <- rgb(51/255, 243/255, 25/255, maxColorValue = 1)
plot1<-ggplot(trn_dat, mapping= aes(x = NGENES, y=Fold1)) + 
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold1, colour='Fold1', 
                                linetype = "TRAIN"),size=0.6)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold2, colour='Fold2', 
                                linetype = "TRAIN"),size=0.6)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold3, colour='Fold3', 
                                linetype = "TRAIN"),size=0.6)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold4, colour='Fold4', 
                                linetype = "TRAIN"),size=0.6)+
  geom_line(data = trn_dat, aes(x = NGENES, y=Fold5, colour='Fold5', 
                                linetype = "TRAIN"),size=0.6)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold1, colour='Fold1', 
                               linetype = "TEST"),size=0.6)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold2, colour='Fold2', 
                               linetype = "TEST"),size=0.6)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold3, colour='Fold3', 
                               linetype = "TEST"),size=0.6)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold4, colour='Fold4', 
                               linetype = "TEST"),size=0.6)+
  geom_line(data= tst_dat, aes(x = NGENES, y=Fold5, colour='Fold5', 
                               linetype = "TEST"),size=0.6)+
  theme_bw()+
  scale_y_continuous(name="Accuracy",limits = c(0.86,1),
                     breaks = round(seq(0.8, 1, by = 0.02),2))+
  scale_x_continuous(name="# Genes",limits = c(1,2),
                     breaks = seq(1, 2, by = 1))+
  scale_color_manual(name='Color',
                     breaks=c('Fold1','Fold2','Fold3','Fold4','Fold5'),
                     values = c('Fold1'=color1, 'Fold2'=color2, 'Fold3'=color3,
                    'Fold4'=color4,'Fold5'=color5))+
  scale_linetype_manual(name= 'Line type', breaks=c('TRAIN','TEST'), 
                        values=c('TRAIN'='solid','TEST'='longdash'))+
theme(legend.key.size = unit(1, 'cm'))

plot1
# +theme(plot.title = element_text(size=12,face='bold',hjust = 0.5)) 
```
```{r}

trn_dat_mean <- apply(trn_dat[,1:5], 1, mean)
trn_dat_mean <- as.data.frame(cbind(trn_dat_mean,trn_dat[,6]))
colnames(trn_dat_mean)[2] <- "NGENES"

tst_dat_mean <-  apply(tst_dat[,1:5], 1, mean)
tst_dat_mean <- as.data.frame(cbind(tst_dat_mean,tst_dat[,6]))
colnames(tst_dat_mean)[2] <- "NGENES"

color1 <- rgb(9/255, 137/255, 134/255, maxColorValue = 1)
color2 <- rgb(255/255, 198/255, 51/255, maxColorValue = 1)


plot1<-ggplot(trn_dat_mean, mapping= aes(x = NGENES, y=trn_dat_mean)) + 
  geom_line(data = trn_dat_mean, aes(x = NGENES, y=trn_dat_mean, 
                                linetype = "TRAIN"),color= color1, linewidth=0.8)+
  geom_line(data = tst_dat_mean, aes(x = NGENES, y=tst_dat_mean, 
                                linetype = "TEST"),color=color1,linewidth=0.8)+
  theme_bw()+
   scale_y_continuous(name="Mean accuracy",limits = c(0.93,1),
                     breaks = round(seq(0.8, 1, by = 0.02),2))+
  scale_x_continuous(name="# Genes (from gene signature)",limits = c(1,2),
                     breaks = seq(1, 2, by = 1))+
  scale_linetype_manual(name= '', breaks=c('TRAIN','TEST'),
        values=c('TRAIN'='solid','TEST'='longdash'))+
  ggtitle("5-FOLD CV - Mean train and test accuracy - gene signature")+
  theme(legend.key.size = unit(1, 'cm'),legend.text=element_text(size=14), axis.text=element_text(size=14),
        axis.title=element_text(size=16),plot.title = element_text(size=15,face='bold',hjust = 0.5))

plot1


#png("mean_acc_train_test_signature.png", units="in", width=10, height=5, res=300)
#plot1
#dev.off()
# +theme(plot.title = element_text(size=12,face='bold',hjust = 0.5)) 
```
```{r}
png("mean_acc_train_test_signature.png", units="in", width=10, height=5, res=300)
plot1
dev.off()
 
```

Boxplot de la expresión de los dos genes de la huella en todas las muestras:

```{r}
dataPlot(expressionMatrixCorrected[selecc,], qualityLabels, mode = "genesBoxplot"
         ,main="CLDN15 and VWCE expression in all samples")
```

Heatmap de la expresión de los genes de la huella realizando submuestreo de las clases cancerosas (21 muestras de cada clase cancerosa, escogidas al azar entre todas las muestras de calidad, además de las 21 muestras sanas). 

```{r}
signature_exp <- t(expressionMatrixCorrected[selecc,])
sign_exp_labels <- as.data.frame(cbind(signature_exp,qualityLabels))
colnames(sign_exp_labels)[3] <- "Class"
cervix21 <- sign_exp_labels[ sample( which( sign_exp_labels$Class == "CERVIX_TUMOR" ) , 21 ) , ]
corpus21 <- sign_exp_labels[ sample( which( sign_exp_labels$Class == "CORPUS_TUMOR" ) , 21 ) , ]
healthy21 <- sign_exp_labels[ which( sign_exp_labels$Class == "HEALTHY" ), ]

all21 <- as.data.frame(rbind(cervix21,corpus21,healthy21))
nrow(all21)

all21_exp <- all21[,-3]
all21_exp$CLDN15 <- as.numeric(all21_exp$CLDN15)
all21_exp$VWCE <- as.numeric(all21_exp$VWCE)
```


```{r}

dataPlot(t(all21_exp), all21$Class, mode = "heatmap",
         main="CLDN15 and VWCE expression using undersampling", toPNG = T)
```


# 7. Enriquecimiento funcional de la huella génica seleccionada.

Obtenemos la anotación funcional de los genes seleccionados y con estas, descargamos la información sobre las ontologías génicas (la función molecular de los productos génicos; su rol en los procesos biológicos; y su localización en componentes celulares).

```{r}

# Cambiamos el nombre del gen por la anotacion funcional
# (identificadores ENTREZ)
# y eliminamos el que no tenga correspondencia.
entrezAnnotation <- getGenesAnnotation(selecc, attributes = 
    c("external_gene_name","entrezgene_id"), filter = "external_gene_name")
entrezGeneIds<- entrezAnnotation$entrezgene_id[!is.na(entrezAnnotation$entrezgene_id)]

# Con estas anotaciones obtenemos las 3 categorías ontológicas.
GOs <- geneOntologyEnrichment(as.character(entrezGeneIds), geneType = 
                                "ENTREZ_GENE_ID")
GOs # También te devuelve el pvlaue, cómo de precisa es la asociación 
# del término GO para ese gen


```
```{r}
# Molecular Function
GO_MF <- GOs$`MF Ontology GOs`
write.csv(file = "GO_MF.csv", x = GO_MF)

# Celular Component
GO_CC <- GOs$`CC Ontology GOs`
write.csv(file = "GO_CC.csv", x = GO_CC)

# Biological Process
GO_BP <- GOs$`BP Ontology GOs`
write.csv(file = "GO_BP.csv", x = GO_BP)

```



Información sobre los pathways:

```{r}
# Se descarga informacion sobre los Pathways
pathways <- DEGsToPathways(entrezAnnotation$external_gene_name)
pathways
```

Obtenemos información sobre las enfermedades relacionadas con los genes seleccionados.

```{r}
# Se descarga informacion sobre las enfermedades relacionadas
# Este no funciona porque consulta una API que ahora ha cambiado la url, el 
#siguiente igual
diseases <- DEGsToDiseases(entrezAnnotation$external_gene_name, getEvidences 
                           = TRUE)

# Lanzamos el report automatico
#knowseqReport(geneExprMatrix,labels,'knowSeq-report',clasifAlgs=c('knn'), 
# qualityAnalysis = F, getDiseases=TRUE, geneOntology=FALSE, maxGenes = 12)

diseases

dis_VWCE <- diseases$VWCE
write.csv(file = "dis_VWCE.csv", x = dis_VWCE)

dis_CLDN15 <- diseases$CLDN15
write.csv(file = "dis_CLDN15.csv", x = dis_CLDN15)
```



